![](https://docs.gitlab.com/ee/workflow/gitlab_flow.png)

> Прим.пер.: Перевод основан на [статье из блога GitLab](https://docs.gitlab.com/ee/workflow/gitlab_flow.html) и является переработанной версией перевода на русский язык авторов [Ivan Nemytchenko](https://gist.github.com/inem/0021b92975c08d89aad7c6f9fd0b2775) и [pingusya](https://gist.github.com/pingusya/c4939b6ec152e3f61920).

# Введение

Git значительно упрощает управление версиями по сравнению с более старыми системами контроля версий – такими, как SVN. Это дает широкий выбор стратегий ведения веток и вариаций рабочих процессов в репозитории. Почти любой вариант при этом более удачен по сравнению с методами до появления git. Однако многие организации используют рабочие процессы без четкой организации, излишне сложные или не интегрированные в системы отслеживания ошибок. Поэтому мы предлагаем рабочий процесс GitLab как четко определенную последовательность лучших практик. Он сочетает [разработку, управляемую функциональностью](https://ru.wikipedia.org/wiki/Feature_driven_development) и [feature-ветки с инструментами отслеживания  ошибок (issue tracking)](http://martinfowler.com/bliki/FeatureBranch.html).

Компании, переходящие на git с других систем контроля версий, часто сталкиваются с проблемой разработки/выбора эффективного рабочего процесса. Данная статья описывает рабочий процесс GitLab, интегрирующий процесс разработки под git с системой отслеживания ошибок. Рабочий процесс предлагает простой, прозрачный и эффективный метод работы с git.

![](https://docs.gitlab.com/ee/workflow/four_stages.png)



При переходе на работу с git вам нужно привыкнуть, что перед тем, как коммит поступит в общий доступ, необходимо пройти три шага. Обычные системы контроля версий используют только один шаг: отправка коммита из локальной копии на общий сервер. 

Перейдя на git, вы вынуждены свыкнуться с фактом, что для того, чтобы поделиться кодом с коллегами, вам придется выполнить как минимум три шага:
* Вы добавляете файлы из рабочей копии в _staging_.
* Затем вы выполняете _commit_ в локальный репозиторий. 
* Третий шаг – отправка (_push_) в общий удаленный репозиторий. 

Освоив эти три шага, можно перейти к изучению модели ветвления.

![](https://docs.gitlab.com/ee/workflow/messy_flow.png)
























Поскольку многие компании, осваивающие git, не имеют представления о работе с системой, то запутаться очень легко. Основная проблема, с которой сталкиваются разработчики – наличие множества долгоживущих веток, каждая из которых содержит часть общих изменений. Трудно разобраться, в какой ветке разработка еще ведется, а какую требуется развернуть на _production_. 

Как правило, в данной ситуации прибегают к применению стандартизированных схем, например, [git flow](http://nvie.com/posts/a-successful-git-branching-model/) или [GitHub flow](http://scottchacon.com/2011/08/31/github-flow.html). Мы считаем, что их тоже можно улучшить и ниже излагаем набор методик, которые мы назвали GitLab flow.

# Git flow и его недостатки

![](https://docs.gitlab.com/ee/workflow/gitdashflow.png)


























Git flow был одним из первых предложений по использованию веток git и привлек массу внимания в свое время. Git flow включает в себя мастер-ветку (_master_) и отдельную ветку для разработки (_develop_), а также дополнительные ветви для фич (_feature_), релизов (_release_) и патчей(_hotfix_). Работа ведется в ветке _develop_, затем переносится в ветвь релиза и, в конце концов, сливается в мастер-ветку. Git flow представляет собой четко определенный стандарт, но его сложность порождает две проблемы. Первая проблема: авторам приходится использовать ветку _develop_ вместо _master_, поскольку master зарезервирован для кода, который отправляется в продакшен. Существует сложившийся обычай называть рабочую ветвь по умолчанию _master_, и делать ответвления и слияния с ней. Большинство инструментов по умолчанию используют это название для основной ветки и по умолчанию выводят именно ее, и бывает неудобно постоянно переключаться вручную на другую ветку. 

Вторая проблема процесса git flow – сложности, возникающие из-за веток для патчей и для релиза. Подобная структура может подойти некоторым организациям, но для абсолютного большинства она просто убийственно излишяя. На сегодняшний день большинство компаний практикуют непрерывное развертывание (continuous delivery), что подразумевает, что основная ветвь по умолчанию может быть задеплоена (_deploy_). А значит, можно избежать использования веток для релиза и патчей, и всех связанных с ними хлопот, например, обратного слияния из веток релизов. Хотя для решения данных задач существуют специальные инструменты,  они требуют документирование процесса и в целом осложняют работу. Часто разработчики по ошибке сливают изменения только в мастер-ветку, забывая про ветвь разработки. И корень всех этих проблем кроется в излишней сложности git flow при решении большинства задач. Кстати, формирование релизов вовсе не означает необходимости формировать патчи (_hotfix_).

# GitHub flow – упрощенная альтернатива

![](https://docs.gitlab.com/ee/workflow/github_flow.png)






















В качестве ответа на стандарт git flow была сформулирована упрощенная альтернатива: процесс [GitHub flow](https://guides.github.com/introduction/flow/index.html). В этом рабочем процессе используются только _feature_-ветки и ветка _master_. Схема очень чистая и простая, и многие компании с большим успехом применяют ее. Atlassian рекомендуют [похожую стратегию](http://blogs.atlassian.com/2014/01/simple-git-workflow-simple/), хотя они и перемещают (_rebase_) feature-ветки. Слияние всех ветвей в мастер-ветвь и частый деплой позволяют минимизировать объем кода, "путешествующего" по системе, что соответствует лучшим техникам упрощенной разработки (_lean_) и непрерывной доставки (_continuous delivery_). Но данная схема все же оставляет открытыми массу вопросов о деплое, средах, релизах и интеграции с баг-трекерами (_issues_). В стандарте GitLab flow мы предлагаем дополнительные рекомендации по данным вопросам.

# Production branch с GitLab flow

![](http://i66.tinypic.com/33yl0jk.png)













GitHub flow предполагает, что вы в праве задеплоить в продакшен каждый раз после слияния _feature_-ветки в _master_. Это справедливо для SaaS-приложений, но во многих случаях такой сценарий неприменим. Один из примеров – ситуация, когда вы не можете управлять моментом релиза, например, если приложение для iOS должно пройти проверку в AppStore. Другой пример – когда у вас существуют строгий промежуток времени для деплоя (рабочие дни с 10 до 18 часов, когда вся команда в сборе), но слияние кода выполняется и в другое время. В этом случае вы можете создать ветвь _production_, отражающую состояние задеплоенного кода. Вы можете задеплоить новую версию, выполнив слияние кода из _master_-ветви в ветку _production_. Если вам необходимо знать состояние кода, задеплоенного в продакшен, вы можете просто выполнить _checkout_ в _production_-ветку. Примерное время деплоя соответствует времени создания коммита слияния в системе контроля версий. Это время достаточно точное, если вы автоматически деплоите ветку в продакшен. Если вам нужно более точное время, вы можете посредством скрипта создавать метку для каждого деплоя. Данная схема предотвращает дополнительные затраты на подготовку релизов, создание меток и слияние, характерное для git flow.

# Ветки сред с GitLab flow

![](https://docs.gitlab.com/ee/workflow/environment_branches.png)



























Хорошей идеей может быть использовать среду, автоматически обновляющуюся к актуальному состоянию мастер-ветки. Лишь только в этом случае имя среды может отличаться от названия ветки. 

Предположим, у вас имеется средя для подготовки (_staging_), среда для пре-продакшена (_pre-production_) и среда для продакшена (_production_). В этом случае мастер-ветвь деплоится на _staging_-среду. Когда кто-либо хочет задеплоить на _pre-production_, он создает запрос на слияние (_merge request_) из мастер-ветви в ветку _pre-production_. Ввод кода в эксплуатацию производится слиянием из ветки _pre-production_ в ветвь _production_. 

Данная схема рабочего процесса, когда коммиты движутся по веткам только в одном направлении (_downstream_), гарантирует, что код тестируется во всех средах. Если вам нужно сформировать и отобрать (_cherry-pick_) коммит с патчем (_hotfix_), то как правило вы ведете его разработку в _feature_-ветке, затем сливаете в _master_ с помощью запроса на слияние (_merge request_). После слияния feature-ветка не удаляется - если в _master_ всё в порядке (а это должно быть так, если вы практикуете [_continuous delivery_](http://martinfowler.com/bliki/ContinuousDelivery.html)), то вы выполняете слияние в другие ветви. Если это не представляется возможным, поскольку требуется ручное тестирование, вы можете отправить запросы на слияние (merge requests) в следующие далее ветви. "Экстремальная" версия ветвей среды – настройка среды для каждой ветви функционала, как это делается в Teatro.

# Ветви релизов с  GitLab flow

![](https://docs.gitlab.com/ee/workflow/release_branches.png)


























Работать с _release_-ветками следует только в случае, если вам необходимо выпускать программное обеспечение во внешний мир (коробочные версии). В этом случае каждая ветвь содержит младшую версию программы (2-3-stable, 2-4-stable, и т.д.). Стабильная ветка использует в качестве точки отсчета _master_ и создается как можно позднее. Создавая ветки как можно позднее, вы сводите к минимуму время, необходимое на исправление общих ошибок в многочисленных ветках. После анонса ветки релиза в эту ветвь попадают только исправления серьезных ошибок. По возможности исправления в первую очередь попадают в _master_, а уже затем отбираются (_cherry_pick_) в _release_-ветки. Такой подход не даст вам забыть перенести их в _master_ и обратить внимание на ту же ошибку в последующих релизах. Такой подход именуется правилом '_upstream first_', которому следуют [Google](https://www.chromium.org/chromium-os/chromiumos-design-docs/upstream-first) и [Red Hat](https://www.redhat.com/about/news/archive/2013/5/a-community-for-using-openstack-with-red-hat-rdo). 

Каждый раз при включении фикса в ветвь релиза увеличивается на единицу патч-версия (для соответствия [системе Семантического Версионирования](http://semver.org/)) путем установки новой метки (_tag_). В некоторых проектах также используется ветвь _stable_, указывающая на тот же самый коммит, что и ветвь последнего релиза. В данной схеме организации рабочего процесса не принято использовать _production_-ветвь (или ветвь _master_ в идеологии _git flow_).

# Запросы Merge/pull с GitLab flow

![](https://docs.gitlab.com/ee/workflow/mr_inline_comments.png)
















Запросы на слияние и принятие изменений (merge/pull requests) создаются в приложениях для управления git-репозиториями. С их помощью вы просите ответственного сотрудника слить (_merge_) две ветки. Такие инструменты, как GitHub и Bitbucket используют термин "_pull request_", поскольку первым ручным действием будет принятие изменений из _feature_-ветки. Инструменты GitLab и Gitorious оперируют термином "_merge request_", поскольку слияние – финальное действие, требуемое от исполнителя. В данной статье мы будем использовать термин "запрос на слияние" (_merge request_). 

Если вы работаете на _feature_-ветке дольше нескольких часов, рекомендуется поделиться промежуточным результатом работы с остальной частью команды. Это можно сделать, создав запрос на слияние, не адресуя его конкретному исполнителю, а вместо этого указав других пользователей в описании или в комментариях (/cc @mark @susan). Это означает, что ветка не готова для слияния, но неплохо бы получить отзывы коллег. Ваши коллеги могут комментировать непосредственно запрос на слияние или отдельные строки кода с помощью строчных комментариев. Запросы на слияние выполняют функцию инструмента для просмотра кода ([_code review_](https://habrahabr.ru/post/142564/)), поэтому вам не потребуется использовать дополнительные инструменты вроде Gerrit или reviewboard. Если при обзоре выявится дефект, любой член команды может сделать коммит и выполнить команду push для исправления. Как правило, это делает создатель запроса merge/pull. Запросы merge/pull автоматически обновляются и отображают изменения кода, когда в ветку отправляются новые коммиты с помощью команды push.

Когда вы считаете, что код готов к слиянию, вы адресуете запрос на слияние человеку, который лучше всего знаком с базой кода, в которую вносятся изменения, и указываете всех остальных сотрудников, от которых вы хотели бы получить отзывы. Если ответственный сотрудник доволен результатом, то он выполняет слияние веток. Если же ответственный сотрудник не уверен в результате, он может закрыть запрос, не выполняя слияния.

В GitLab принято защищать долгоживущие ветки (например, _master_-ветвь), и, как правило, разработчики не могут изменять эти защищенные ветки, это нормально. Если вы хотите внести изменения в защищенную ветку, вы направляете запрос на слияние сотруднику с соответствующими правами доступа.

# Ведение проблем с GitLab flow

![](https://docs.gitlab.com/ee/workflow/merge_request.png)
















GitLab flow призван сделать связь между кодом и системой отслеживания ошибок более прозрачной.
> пер.: Здесь и далее _issue_ - это не только ошибка, баг, но и новая функциональность. В общем смысле - задача, запрос на изменение системы.

Любое значительное изменение кода должно начинаться с создания в системе задачи (_issue_) с описанием цели изменений. Очень важно иметь обоснование для каждого изменения кода. Это позволяет проинформировать всю команду и помогает разработчикам минимизировать охват ветки функционала. В GitLab каждое изменение кодовой базы начинается с заведения _issue_ в системе отслеживания ошибок. Новая _issue_ создается при условии, что для ее устранения потребуется серьезные усилия (не менее 1 часа работы). Для многих организаций это требование выполняется автоматически, поскольку сначала производится предварительная оценка трудозатрат на выполнение задачи. Названия _issue_ должно описывать желаемое состояние системы, например "Как администратор, я хочу удалять пользователей, не получая ошибки" вместо "Админ не может удалять юзеров".

Когда вы готовы начать работу с кодом, вы создаете от _master_-ветви ветку для решения данной _issue_. Название ветки должно начинаться с номера проблемы, например  '15-require-a-password-to-change-it'.

По завершению работы или если вы хотите обсудить код, вы открываете запрос на слияние (_merge request_). Тем самым вы создаете онлайн-пространство для обсуждения изменений и обзора кода. Открытие запроса на слияние выполняется вручную, поскольку не всегда требуется слияние ветви, над которой вы работаете (это может быть _release_-ветка или долгосрочная задача). Если вы открываете запрос на слияние, при этом не адресуя его конкретным сотрудникам -- это "рабочий" запрос на слияние ('_Work In Progress_'). Такие запросы используются для обсуждения предлагаемой реализации, которая еще не готова для отправки в _master_. _Совет от профи_:  начинайте имя запроса на слияние с `[WIP]` или `WIP:`, чтобы результат не сливался в _master_ до готовности кода.

Когда автор считает, что код готов, запрос на слияние адресуется ответственному рецензенту. Рецензент нажимает кнопку "слияние", если он уверен, что код готов для включения в _master_. В этом случае производится слияние кода и создается коммит слияния (_merge commit_), что позволяет в дальнейшем с легкостью отследить данное событие. Запросы на слияние всегда создают коммиты слияния, даже если коммит можно добавить без непосредственно слияния. Подобная стратегия слияния называется "без перемотки" ('_no fast-forward_') в git. После слияния ветка функционала удаляется, поскольку в ней уже нет необходимости, в GitLab данное удаление является опциональным при слиянии.

Предположим, что было выполнено слияние ветки, но выявился дефект, и ошибка снова была открыта. В этом случае можно без проблем использовать прежнее название ветки, поскольку при слиянии она была удалена. В каждый момент времени существует не более одной ветки для каждой ошибки. При этом одна _feature_-ветка может решать несколько задач (_issue_).

# Ссылки на ошибки и закрытие ошибок из запросов на слияние

![](https://docs.gitlab.com/ee/workflow/close_issue_mr.png)





























Ссылку на ошибку можно создать, упомянув ошибку в комментарии к коммиту (`исправляет #14`, `закрывает #67`, и.т.п.) или в описании запроса на слияние. В GitLab при этом в ошибке, упомянутой в запросе на слияние, создается комментарий, и запрос на слияние показывает ошибку, на которую поставлена ссылка. Ошибка закрывается, когда код сливается в основную ветку.

Если вы хотите только упомянуть ошибку, не закрывая ее, вы можете просто оставить упоминание: "`Предпочтительна неявная типизация. #12`".

Если вы работаете над ошибкой, которая распространяется на несколько репозиториев, лучше всего создать отдельную ошибку для каждого репозитория и создать ссылки от всех к родительской ошибке.

# Уплотнение коммитов при перемещении

![](https://docs.gitlab.com/ee/workflow/rebase.png)




























Система git позволяет использовать интерактивное перемещение (`rebase -i`) для уплотнения и сортировки нескольких коммитов в один. На GitLab EE и .com вы также можете использовать перемещение перед слиянием из веб-интерфейса. Эта функция полезна в случае, если во время разработки вы отправили несколько коммитов с мелкими изменениями и хотите заменить их на единый коммит или расположить их в более логичном порядке. Однако никогда не перемещайте коммиты, отправленные с помощью команды _push_ на удаленный сервер. Кто-то из ваших коллег мог сослаться на ваши коммиты или использовать их выборочно (_cherry-pick_). При перемещении изменяется идентификатор (SHA-1) коммита, и это может внести путаницу. Если вы сделаете это, то одни и те же изменения будут обозначены несколькими идентификаторами, что может серьезно затруднить работу. Если коллеги уже просматривали ваш код, им будет сложно просмотреть только последние изменения, если с тех пор вы все переместили в один коммит. Другая причина не использовать перемещение в том, что вы стираете информацию об авторстве. Может быть, один разработчик создал запрос на слияние, второй отправил коммит для улучшения кода, а третий разработчик выполнил слияние. В этом случае перемещение всех коммитов в один не позволит остальным разработчикам быть корректно упомянутыми и получить свою [долю признания](https://git-scm.com/docs/git-blame) в git.

Разработчикам рекомендуется почаще выполнять коммиты и отправлять изменения в удаленный репозиторий, чтобы остальные понимали, над чем работают коллеги. Это приводит к большому числу коммитов на одно изменение, что затрудняет понимание истории. Однако преимущества наличия постоянных идентификаторов для коммитов перевешивают эту трудность (пер.: имеется в виду возможность для других участников разработки опираться на актуальные коммиты из feature-веток). Для понимания контекста, в котором производились изменения, вcегда можно взглянуть на коммит слияния, группирующий все коммиты, когда код сливается с _master_.

После того, как слияние нескольких коммитов из _feature_-ветки в _master_ произведено, откатиться обратно становится нетривиальной задачей. Если вы уплотнили (_squash_) все коммиты в один, то можно просто откатить этот коммит, но, как уже говорилось ранее, не следует перемещать (_rebase_) коммиты после отправки (_push_) в репозиторий. К счастью, git позволяет [откатить слияние, произведенное некоторое время назад](https://git-scm.com/blog/2010/03/02/undoing-merges.html). Однако для этого требуется наличия конкретных коммитов слияния (merge commit) для тех коммитов, которые вы хотите отменить. Если вы отменяете слияние, а потом изменяете свое решение, вам придется отменить отмену (пер.: holy sh*t) вместо нового слияния, поскольку git не позволит вам  слить код иным образом.

Возможность отмены слияния – хорошая причина всегда создавать коммит слияния (_merge commit_), если вы выполняете слияние вручную через опцию `--no-ff` . Программы управления git всегда создают коммит слияния, если вы принимаете запрос на слияние. 

# Не меняйте порядок коммитов при перемещении

![](https://docs.gitlab.com/ee/workflow/merge_commits.png)




























Система git помимо прочего позволяет перемещать (_rebase_) коммиты _feature_-веток, располагая их вслед за коммитами _master_-а. Это предотвращает создание коммита слияния (_merge commit_) при слиянии мастер-ветки в _feature_-ветку и создает удобную и наглядную линейную историю. Однако, как и в случае с перемещением (_squash_), не следует перемещать коммиты, которые были отправлены на удаленный сервер с помощью команды _push_. Из-за этого вы не сможете переместить работу в процессе, которой вы уже поделились с коллегами (а именно такой подход мы крайне рекомендуем). Если вы используете перемещение (_rebase_) при обновлении _feature_-ветки, вам придется [снова и снова разрешать похожие конфликты](https://blogs.atlassian.com/2013/10/git-team-workflows-merge-or-rebase/). Иногда можно повторно использовать сохраненные разрешения конфликтов ([rerere](https://git-scm.com/blog/2010/03/08/rerere.html)), но если вы всё-таки откажетесь от практики перемещения (_rebase_), вам придется лишь один раз разрешить конфликты. Должен быть более удобный способ избежать множества конфликтов слияния.

Основной способ избежать возникновения множества коммитов слияния – избегать частого слияния _master_ в _feature_. Мы рассмотрим три основных причины для слияния с мастер-веткой: изменения кода, влияющие на все ветки, конфликты слияния и долгоживущие ветки. Если вам нужно применить часть кода, появившуюся в мастер-ветке после того, как вы создали _feature_-ветку, иногда для решения достаточно использовать выборочно (_cherry-pick_) отдельный коммит. Если в вашей _feature_-ветке возник конфликт слияния, создание коммита слияния – нормальный способ решения проблемы. Вы можете предотвратить возникновение некоторых конфликтов слияния, используя [gitattributes](http://git-scm.com/docs/gitattributes) для файлов, изменения в которых могут располагаться в любом порядке. Например, в GitLab наш `changelog` в `.gitattributes` прописан следующим образом: `CHANGELOG merge=union`, чтобы возникало меньше конфликтов слияния. И последняя причина создания коммита слияния – наличие долгоживущих веток, которые должны отражать текущее состояние проекта. Мартин Фаулер в своей [статье о feature-ветвях](http://martinfowler.com/bliki/FeatureBranch.html) говорит о понятии "непрерывная интеграция" (_Continuous Integration_ или CI). Мы в GitLab признаемся, что путали CI с тестированием веток. Цитата Мартина Фаулера: 
>"Я слышал, как люди заявляют, что используют CI, поскольку они запускают билды, возможно, используя CI сервер, на каждой ветке с каждым коммитом. Это называется непрерывным построением (continuous building), и это хорошая практика, но здесь нет интеграции, а значит, это не CI". 

Для предотвращения многочисленных коммитов слияния нужно стараться ограничивать цикл жизни _feature_-веток, большинство из них должно занимать менее дня работы. Если ваши _feature_-ветки, как правило, требуют больше дня работы, обдумайте возможность выделения меньших блоков работы и/или используйте ротацию функций ([_feature toggle_](http://martinfowler.com/bliki/FeatureToggle.html)). Для работы с долгоживущими ветками, которые требуют более дня работы, существует две стратегии. В стратегии CI вы можете выполнять слияние с мастер-веткой в начале каждого дня, чтобы избежать затруднений в слиянии позже. В стратегии точек синхронизации (_synchronization point_) вы выполняете слияние только в четко установленные моменты времени, например в отмеченный релиз (_tagged release_). Линус Торвальдс [поддерживает данную стратегию](https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html), поскольку в подобные моменты лучше известно состояние кода.

GitLab Enterprise Edition предлагает возможность перемещения перед созданием запроса на слияние. Вы можете настроить эту возможность для каждого отдельного проекта, перейдя на страницу настроек проекта и выбрав галочку `Merge Requests Rebase`.

![](https://docs.gitlab.com/ee/workflow/merge_request_settings.png)

Перед принятием запроса на слияние, выберите "rebase before merge". 

![](https://docs.gitlab.com/ee/workflow/merge_request_widget.png)

GitLab сделает попытку провести чистое перемещение перед слиянием веток. Если чистое перемещение невозможно, будет произведено обычное слияние. Если чистое перемещение возможно, при слиянии будет изменена история целевой ветки. 

В завершение скажем, что вам следует избегать коммитов слияния, но не отказываться от них полностью. Ваша база кода должна оставаться чистой, но история должна отражать реальный ход работы. Разработка программного обеспечения требует множества путанных мелких шагов, и ваша история должна корректно отражать их. Вы можете использовать инструменты для просмотра сетевых графов коммитов, чтобы понять историю создания своего кода. Если вы используете перемещение, история изменяется, и инструменты не смогут это исправить, потому что они не умеют обрабатывать изменения идентификаторов коммитов.

# Эмодзи в проблемах и запросах на слияние

![](https://docs.gitlab.com/ee/workflow/award_emoji.png)

Общепринято озвучивать свое одобрение или неодобрение с помощью +1 или -1. В GitLab вы можете использовать эмодзи, чтобы виртуально "дать пять" в обсуждении проблем и запросах на слияние.

# Отправка (pushing) и удаление веток

![](https://docs.gitlab.com/ee/workflow/remove_checkbox.png)

Мы рекомендуем отправлять код из веток функционала с помощью _push_ как можно чаще, даже если он еще не готов к просмотру. Следуя этому правилу, вы избежите ситуаций, когда несколько коллег случайно начинают работу над одной и той же проблемой. Конечно, этой ситуации можно избежать простым назначением исполнителя проблемы в системе отслеживания ошибок. Но зачастую кто-то просто забывает назначить исполнителя в баг-трекере. После слияния ветки ее следует удалить из системы управления исходным кодом. В GitLab и подобных системах эту возможность предлагают при слиянии. Это гарантирует, что обзор веток в системе управления репозиторием показывает только выполняемую работу. Кроме того, если кто-то заново открывает проблему в новой ветке, можно использовать прежнее имя без всяких проблем. При новом открытии проблемы необходимо создать новый запрос на слияние.

# Частые коммиты с правильными комментариями

![](https://docs.gitlab.com/ee/workflow/good_commit.png)

Мы рекомендуем выполнять коммиты как можно раньше и чаще. Каждый раз, когда у вас имеется рабочий набор кода и тестов, вы можете выполнить коммит. Преимущество в том, что если доработка или рефакторинг что-то ломают, достаточно просто откатиться на рабочую версию. Такой подход серьезно меняет точку зрения для программистов, работавших ранее с SVN, поскольку они выполняли коммиты, когда работа была готова для общего использования. Правильный подход: использовать запросы на слияние и на принятие изменений (merge/pull requests) с несколькими коммитами, когда вы готовы поделиться рабочим кодом с другими. Комментарий к коммиту должен отражать ваши намерения, а не содержимое коммита. Содержимое коммита и так легко видно, вопрос в том, зачем вы выполняли работу. Пример хорошего комментария к коммиту: 
> "Скомбинированы шаблоны для оптимизации user views". 

Можно назвать несколько терминов, которые не годятся для комментирования коммита, поскольку содержат недостаточно информации: _изменение_, _улучшение_ и _реорганизация_ (рефакторинг). Термин "_исправление_" или "_фикс_" – тоже тревожный признак, если только он не идет в конце описания коммита и не ссылается на номер ошибки. Более подробную информацию о форматировании комментариев к коммитам вы найдете [в этом прекрасном посте в блоге Tim Pope](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html).

# Тестирование перед слиянием

![](https://docs.gitlab.com/ee/workflow/ci_mr.png)

В прежних системах организации рабочего процесса сервер непрерывной интеграции (CI), как правило, запускал тесты только на мастер-ветке. Разработчикам приходилось заботится о том, чтобы их код не ломал мастер-ветку. При использовании процесса GitLab flow  разработчики создают свои ветки от данной мастер-ветви, поэтому крайне важно, чтобы она была "зеленой". Поэтому необходимо проводить тестирование каждого запроса на слияние перед его одобрением. Программное обеспечение CI, например, `Travis` и `GitLab CI`, показывают результат построения билда непосредственно в запросе на слияние, существенно упрощая процесс. Есть только одно затруднение: программы тестируют саму ветку функционала, а не результат слияния. Но ситуацию можно исправить, протестировав непосредственно результат слияния. Проблема в том, что результат слияния меняется при каждом слиянии в мастер-ветку. Повторение тестов для каждого коммита в мастер-ветку требует больших затрат вычислений, а значит, вы чаще будете ожидать результатов тестирования. Если не возникает конфликтов слияния и ветки функционала существуют недолго, то риски оправданны. При возникновении конфликтов слияния вы выполняете слияние мастер-ветки в ветку функционала, и  сервер CI повторяет тесты. Если у вас долгоживущие ветки функционала, используемые более нескольки дней, вам следует разбивать работу на меньшие блоки.

# Слияние с другим кодом

![](https://docs.gitlab.com/ee/workflow/git_pull.png)

При инициации _feature_-ветки всегда выбирайте для ответвления актуальную мастер-ветку. Если вам заранее известно, что ваша задача сильно зависит от другой ветки, можете выполнить ответвление от нее. Если вам необходимо выполнить слияние с другой веткой, объясните причины в коммите слияния. Если вы еще не отправляли свои коммиты в репозиторий общего доступа, вы  можете произвести перемещение (_rebase_) в _master_ или другую _feature_-ветку. Не выполняйте слияния в upstream, если ваш код будет работать и сольется (_merge_) без конфликтов и без этого. Линус строго рекомендует [никогда не выполнять слияния в upstream в произвольные моменты времени -- только в ключевых релизах](https://lwn.net/Articles/328438/). Слияние по необходимости позволяет избежать конфликтов слияния в _feature_-ветке, которые позже загрязняют историю мастер-ветки.
